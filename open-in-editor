#!/usr/bin/env python3
'''
This scripts allows triggering opening emacs from a link on a webpage/browser extension via MIME.
Handles links like:

   editor:///path/tofile:123

See test_parse_uri for more examples.

To install (register the MIME handler), run

   python3 open-in-editor --editor emacs --install

See --help for the list of available editors. If you want to add other editors, the code should be easy to follow.

You can check that it works with

   xdg-open 'editor:///path/to/some/file'

I haven't found any existing/mature scripts for this, please let me know if you know of any! I'd be happy to support one less script.
'''
# TODO make it editor-agnostic? although supporting line numbers will be trickier


PROTOCOL_NAME = 'editor'


# TODO FIXME add a test for : in filename
def test_parse_uri():
    assert parse_uri('editor:///path/to/file') == (
        '/path/to/file',
        None,
    )

    assert parse_uri('editor:///path/with spaces') == (
        '/path/with spaces',
        None,
    )

    assert parse_uri('editor:///path/url%20encoded') == (
        '/path/url encoded',
        None,
    )

    # TODO FIXME not sure about this..
    assert parse_uri('editor:///path/to/file/and/line:10') == (
        '/path/to/file/and/line',
        10,
    )

    import pytest # type: ignore
    with pytest.raises(Exception):
        parse_uri('badmime://whatever')


def test_open_editor():
    import time
    from tempfile import TemporaryDirectory
    with TemporaryDirectory() as td:
        p = Path(td) / 'some file.org'
        p.write_text('''
line 1
line 2
line 3 ---- THIS LINE SHOULD BE IN FOCUS!
line 4
'''.strip())
        # todo eh, warns about swapfile
        for editor in EDITORS.keys():
            open_editor(f'editor://{p}:3', editor=editor)
        input("Press enter when ready")


import argparse
from pathlib import Path
import sys
import subprocess
from subprocess import check_call, run
import tempfile
from urllib.parse import unquote



def notify(what) -> None:
    # notify-send used as a user-facing means of error reporting
    run(["notify-send", what])


def error(what) -> None:
    notify(what)
    raise RuntimeError(what)


def install(editor: str) -> None:
    this_script = str(Path(__file__).absolute())
    CONTENT = f"""
[Desktop Entry]
Name=Open file in your text editor
Exec=python3 {this_script} --editor {editor} %u
Type=Application
Terminal=false
MimeType=x-scheme-handler/{PROTOCOL_NAME};
""".strip()
    with tempfile.TemporaryDirectory() as td:
        pp = Path(td) / 'open-in-editor.desktop'
        pp.write_text(CONTENT)
        check_call(['desktop-file-validate', str(pp)])
        dfile = Path('~/.local/share/applications').expanduser()
        check_call([
            'desktop-file-install',
            '--dir', dfile,
            '--rebuild-mime-info-cache',
            str(pp),
        ])
        print(f"Installed {pp.name} file to {dfile}", file=sys.stderr)
        print(f"""You might want to check if it works with "xdg-open '{PROTOCOL_NAME}:///path/to/some/file'" """, file=sys.stderr)


from typing import Tuple, Optional, List
Line = int
File = str
def parse_uri(uri: str) -> Tuple[File, Optional[Line]]:
    proto = PROTOCOL_NAME + '://'
    if not uri.startswith(proto):
        error(f"Unexpected protocol {uri}")
        # not sure if a good idea to keep trying?

    uri = uri[len(proto):]
    spl = uri.split(':')

    linenum: Optional[int] = None
    if len(spl) == 1:
        pass # no lnum specified
    elif len(spl) == 2:
        uri = spl[0]
        # TODO could use that for column number? maybe an overkill though..
        # https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html
        linenum = int(spl[1])
    else:
        # TODO what if it actually has colons?
        error(f"Extra colons in URI {uri}")
    uri = unquote(uri)
    return (uri, linenum)



def open_editor(uri: str, editor: str) -> None:
    uri, line = parse_uri(uri)

    # TODO seems that sublime and atom support :line:column syntax? not sure how to pass it through xdg-open though
    opener = EDITORS.get(editor, None)

    if opener is None:
        notify(f'Unexpected editor {editor}! Falling back to vim')
        opener = open_vim
    opener(uri, line)


def with_line(uri: File, line: Optional[Line]) -> List[str]:
    return [uri] if line is None else [f'+{line}', uri]


def open_default(uri: File, line:Optional[Line]) -> None:
    import shutil
    for open_cmd in ['xdg-open', 'open']:
        if shutil.which(open_cmd):
            # sadly no generic way to handle line for editors?
            check_call([open_cmd, uri])
            break
    else:
        error("No xdg-open/open found, can't figure out default editor. Fallback to vim!")
        open_vim(uri=uri, line=line)


def open_gvim(uri: File, line: Optional[Line]) -> None:
    args = with_line(uri, line)
    cmd = [
        'gvim',
        *args,
    ]
    check_call(['gvim', *args])


def open_vim(uri: File, line: Optional[Line]) -> None:
    args = with_line(uri, line)
    launch_in_terminal(['vim', *args])


def open_emacs(uri: File, line: Optional[Line]) -> None:
    args = with_line(uri, line)
    cmd = [
        'emacsclient',
        '--create-frame',
        # trick to run daemon if it isn't https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html
        '--alternate-editor=""',
        *args,
    ]
    # todo exec?
    check_call(cmd)
    return

    ### alternatively, if you prefer a terminal emacs
    cmd = [
        'emacsclient',
        '--tty',
        '--alternate-editor=""',
        *args,
    ]
    launch_in_terminal(cmd)
    ###


EDITORS = {
    'emacs'  : open_emacs,
    'vim'    : open_vim,
    'gvim'   : open_gvim,
    'default': open_default,
}


def launch_in_terminal(cmd: List[str]):
    import shlex
    check_call([
        # NOTE: you might need xdg-terminal on some systems
        "x-terminal-emulator",
        "-e",
        ' '.join(map(shlex.quote, cmd)),
    ])


def main():
    p = argparse.ArgumentParser()
    # TODO allow passing a binary?
    p.add_argument('--editor', type=str, default='vim', choices=EDITORS.keys(), help="Editor to use. 'default' means using your default GUI editor (discovered with open/xdg-open)")
    p.add_argument('--install', action='store_true', help='Pass to install (i.g. register MIME in your system)')
    p.add_argument('uri', nargs='?', help='URI to open + optional line number')
    p.add_argument('--run-tests', action='store_true', help='Pass to run unit tests')
    args = p.parse_args()
    if args.run_tests:
        # fuck, pytest can't run against a file without .py extension?
        test_parse_uri()
        test_open_editor()
    elif args.install:
        install(editor=args.editor)
    else:
        open_editor(args.uri, editor=args.editor)


if __name__ == '__main__':
    main()
